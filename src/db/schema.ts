import { relations, sql } from "drizzle-orm";
import { sqliteTable, text, uniqueIndex, integer } from "drizzle-orm/sqlite-core";

/**
 * Authentication schema.
 *
 * Generated by better-auth CLI.
 *
 * Only make changes to these tables if you know what you're doing.
 */
export const user = sqliteTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: integer("email_verified", { mode: "boolean" })
    .default(false)
    .notNull(),
  image: text("image"),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = sqliteTable("session", {
  id: text("id").primaryKey(),
  expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
  token: text("token").notNull().unique(),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" })
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

export const account = sqliteTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: integer("access_token_expires_at", {
    mode: "timestamp_ms",
  }),
  refreshTokenExpiresAt: integer("refresh_token_expires_at", {
    mode: "timestamp_ms",
  }),
  scope: text("scope"),
  password: text("password"),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" })
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const verification = sqliteTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" })
    .default(sql`(cast(unixepoch('subsecond') * 1000 as integer))`)
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

/**
 * Below, feel free to delete/update/add tables as you see fit for your app.
 */
export const demoData = sqliteTable("demo_data", {
  id: integer("id").primaryKey(),
  header: text("header").notNull(),
  type: text("type").notNull(),
  status: text("status").notNull(),
  target: integer("target").notNull(),
  limit: integer("limit").notNull(),
  reviewer: text("reviewer").notNull(),
});

export const categories = sqliteTable(
  "categories",
  {
    id: integer("id").primaryKey({ autoIncrement: true }),
    name: text("name").notNull(),
    createdAt: text("created_at").notNull().default(sql`(CURRENT_TIMESTAMP)`),
  },
  (t) => ({
    nameUnique: uniqueIndex("categories_name_unique").on(t.name),
  }),
);

export const categoriesRelations = relations(categories, ({ many }) => ({
  questions: many(questions),
  roundCategories: many(roundCategories),
}));

// --------------------
// Fragen (Clues)
// --------------------
export const questions = sqliteTable("questions", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  categoryId: integer("category_id").notNull().references(() => categories.id, {
    onDelete: "cascade",
  }),
  prompt: text("prompt").notNull(),
  answer: text("answer").notNull(),
  value: integer("value").notNull(),
  createdAt: text("created_at").notNull().default(sql`(CURRENT_TIMESTAMP)`),
});

export const questionsRelations = relations(questions, ({ one, many }) => ({
  category: one(categories, {
    fields: [questions.categoryId],
    references: [categories.id],
  }),
  roundClues: many(roundClues),
}));

// --------------------
// Games (optional)
// --------------------
export const games = sqliteTable("games", {
  id: text("id").primaryKey(), // UUID als Text
  status: text("status").notNull().default("active"),
  createdAt: text("created_at").notNull().default(sql`(CURRENT_TIMESTAMP)`),
});

export const gamesRelations = relations(games, ({ many }) => ({
  rounds: many(rounds),
}));

// --------------------
// Rounds
// --------------------
export const rounds = sqliteTable("rounds", {
  id: text("id").primaryKey(), // UUID als Text
  gameId: text("game_id").notNull().default("default"),
  roundNumber: integer("round_number").notNull().default(1),
  status: text("status").notNull().default("open"),
  seed: text("seed"),
  createdAt: text("created_at").notNull().default(sql`(CURRENT_TIMESTAMP)`),
});

// --------------------
// Round -> Kategorien (6 Spalten eingefroren)
// --------------------
export const roundCategories = sqliteTable(
  "round_categories",
  {
    id: integer("id").primaryKey({ autoIncrement: true }),
    roundId: text("round_id")
      .notNull()
      .references(() => rounds.id, { onDelete: "cascade" }),
    categoryId: integer("category_id")
      .notNull()
      .references(() => categories.id, { onDelete: "restrict" }),
    columnIndex: integer("column_index").notNull(), // 0..5
  },
  (t) => ({
    uniqRoundColumn: uniqueIndex("round_categories_round_col_unique").on(
      t.roundId,
      t.columnIndex,
    ),
    uniqRoundCategory: uniqueIndex("round_categories_round_cat_unique").on(
      t.roundId,
      t.categoryId,
    ),
  }),
);

export const roundCategoriesRelations = relations(
  roundCategories,
  ({ one }) => ({
    round: one(rounds, {
      fields: [roundCategories.roundId],
      references: [rounds.id],
    }),
    category: one(categories, {
      fields: [roundCategories.categoryId],
      references: [categories.id],
    }),
  }),
);

// --------------------
// Round -> Clues (5 Zeilen je Spalte eingefroren)
// --------------------
export const roundClues = sqliteTable(
  "round_clues",
  {
    id: integer("id").primaryKey({ autoIncrement: true }),
    roundId: text("round_id")
      .notNull()
      .references(() => rounds.id, { onDelete: "cascade" }),
    questionId: integer("question_id")
      .notNull()
      .references(() => questions.id, { onDelete: "restrict" }),
    columnIndex: integer("column_index").notNull(), // 0..5 (zugehörige Spalte)
    rowIndex: integer("row_index").notNull(), // 0..4 (Zeile/Punktehöhe)
    revealed: integer("revealed").notNull().default(0), // 0/1
    answered: integer("answered").notNull().default(0), // 0/1
    answeredAt: text("answered_at"),
  },
  (t) => ({
    uniqCell: uniqueIndex("round_clues_round_col_row_unique").on(
      t.roundId,
      t.columnIndex,
      t.rowIndex,
    ),
    uniqQuestionInRound: uniqueIndex("round_clues_round_question_unique").on(
      t.roundId,
      t.questionId,
    ),
  }),
);

export const roundCluesRelations = relations(roundClues, ({ one }) => ({
  round: one(rounds, { fields: [roundClues.roundId], references: [rounds.id] }),
  question: one(questions, {
    fields: [roundClues.questionId],
    references: [questions.id],
  }),
}));

// --------------------
// Round -> Players
// --------------------
export const roundPlayers = sqliteTable(
  "round_players",
  {
    id: integer("id").primaryKey({ autoIncrement: true }),
    roundId: text("round_id")
      .notNull()
      .references(() => rounds.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    role: text("role").notNull().default("player"),
    score: integer("score").notNull().default(0),
    joinedAt: text("joined_at").notNull().default(sql`(CURRENT_TIMESTAMP)`),
  },
  (t) => ({
    uniqRoundUser: uniqueIndex("round_players_round_user_unique").on(
      t.roundId,
      t.userId,
    ),
  }),
);

export const roundPlayersRelations = relations(roundPlayers, ({ one }) => ({
  round: one(rounds, {
    fields: [roundPlayers.roundId],
    references: [rounds.id],
  }),
  participant: one(user, {
    fields: [roundPlayers.userId],
    references: [user.id],
  }),
}));

export const roundsRelations = relations(rounds, ({ one, many }) => ({
  game: one(games, { fields: [rounds.gameId], references: [games.id] }),
  roundCategories: many(roundCategories),
  roundClues: many(roundClues),
  roundPlayers: many(roundPlayers),
}));

// --------------------
// Abgeleitete Typen
// --------------------
export type Category = typeof categories.$inferSelect;
export type NewCategory = typeof categories.$inferInsert;

export type Question = typeof questions.$inferSelect;
export type NewQuestion = typeof questions.$inferInsert;

export type Game = typeof games.$inferSelect;
export type NewGame = typeof games.$inferInsert;

export type Round = typeof rounds.$inferSelect;
export type NewRound = typeof rounds.$inferInsert;

export type RoundCategory = typeof roundCategories.$inferSelect;
export type NewRoundCategory = typeof roundCategories.$inferInsert;

export type RoundClue = typeof roundClues.$inferSelect;
export type NewRoundClue = typeof roundClues.$inferInsert;

export type RoundPlayer = typeof roundPlayers.$inferSelect;
export type NewRoundPlayer = typeof roundPlayers.$inferInsert;
